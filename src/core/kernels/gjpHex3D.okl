#define surfaceTerms(sk, face, m, i, j)                                                                      \
  {                                                                                                          \
    const dlong idM = vmapM[sk];                                                                             \
    const dfloat nx = sgeo[sk * p_Nsgeo + p_NXID];                                                           \
    const dfloat ny = sgeo[sk * p_Nsgeo + p_NYID];                                                           \
    const dfloat nz = sgeo[sk * p_Nsgeo + p_NZID];                                                           \
    if (face == 0 || face == 5) {                                                                            \
      s_flux2[m][j][i] = sgeo[sk * p_Nsgeo + p_NDOTTID];                                                     \
    }                                                                                                        \
    if (face == 1 || face == 3) {                                                                            \
      s_flux2[m][j][i] = sgeo[sk * p_Nsgeo + p_NDOTSID];                                                     \
    }                                                                                                        \
    if (face == 2 || face == 4) {                                                                            \
      s_flux2[m][j][i] = sgeo[sk * p_Nsgeo + p_NDOTRID];                                                     \
    }                                                                                                        \
    const dfloat udotn = (nx * U[idM + 0 * offset] + ny * U[idM + 1 * offset] + nz * U[idM + 2 * offset]);   \
    const dfloat hFace = h[face + p_Nfaces * e];                                                             \
    s_flux2[m][j][i] *= (EToB[face + p_Nfaces * e] < 1)                                                      \
      ? fabs(udotn) * hFace * hFace * G[sk] * sgeo[sk * p_Nsgeo + p_WSJID]                                   \
      : 0;                                                                                                   \
  }

@kernel void gjpHex3D(const dlong Nelements,
                      const dlong offset,
                      const dfloat NscalingFactor,
                      @ restrict const dfloat *D,
                      @ restrict const dlong *vmapM,
                      @ restrict const dfloat *vgeo,
                      @ restrict const dfloat *sgeo,
                      @ restrict const int *EToB,
                      @ restrict const dfloat *coef,
                      @ restrict const dfloat *h,
                      @ restrict const dfloat *U,
                      @ restrict const dfloat *G,
                      @ restrict dfloat *out)
{
  for (dlong e = 0; e < Nelements; e++; @outer(0)) {
    @shared dfloat s_flux2[2][p_Nq][p_Nq];

    @exclusive dfloat r_sum[p_Nq];

    @shared dfloat s_D[p_Nq][p_Nq];

    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
        s_D[j][i] = D[j * p_Nq + i];
      }
    }
    @barrier();

    // face 0 & 5 (r-s plane)
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; ++k) {
          r_sum[k] = 0.;
        }

        const dlong sk0 = e * p_Nfp * p_Nfaces + 0 * p_Nfp + i + j * p_Nq;
        const dlong sk5 = e * p_Nfp * p_Nfaces + 5 * p_Nfp + i + j * p_Nq;
        surfaceTerms(sk5, 5, 1, i, j);
        surfaceTerms(sk0, 0, 0, i, j);
      }
    }

    @barrier();

    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          r_sum[k] += s_D[0][k] * s_flux2[0][j][i];
          r_sum[k] += s_D[p_Nq - 1][k] * s_flux2[1][j][i];
        }
      }
    }

    @barrier();

    // face 1 & 3 (r-t plane)
    for (int k = 0; k < p_Nq; ++k; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
        const dlong sk1 = e * p_Nfp * p_Nfaces + 1 * p_Nfp + i + k * p_Nq;
        const dlong sk3 = e * p_Nfp * p_Nfaces + 3 * p_Nfp + i + k * p_Nq;

        surfaceTerms(sk1, 1, 0, i, k);
        surfaceTerms(sk3, 3, 1, i, k);
      }
    }

    @barrier();

    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          r_sum[k] += s_D[0][j] * s_flux2[0][k][i];
          r_sum[k] += s_D[p_Nq - 1][j] * s_flux2[1][k][i];
        }
      }
    }

    @barrier();

    // face 2 & 4 (s-t plane)
    for (int k = 0; k < p_Nq; ++k; @inner(1)) {
      for (int j = 0; j < p_Nq; ++j; @inner(0)) {
        const dlong sk2 = e * p_Nfp * p_Nfaces + 2 * p_Nfp + j + k * p_Nq;
        const dlong sk4 = e * p_Nfp * p_Nfaces + 4 * p_Nfp + j + k * p_Nq;

        surfaceTerms(sk2, 2, 0, j, k);
        surfaceTerms(sk4, 4, 1, j, k);
      }
    }

    @barrier();

    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          r_sum[k] += s_D[p_Nq - 1][i] * s_flux2[0][k][j];
          r_sum[k] += s_D[0][i] * s_flux2[1][k][j];
        }
      }
    }

    @barrier();

    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; ++k) {
          const dlong gid = e * p_Np * p_Nvgeo + k * p_Nq * p_Nq + j * p_Nq + i;
          const dfloat invJw = vgeo[gid + p_IJWID * p_Np];

          const dlong id = e * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          out[id] -= invJw * NscalingFactor * coef[id] * r_sum[k];
        }
      }
    }
  }
}

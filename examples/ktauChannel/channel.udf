#include "RANSktau.hpp"

#include "ci.inc"

static dfloat rho, mueLam;

#ifdef __okl__

@kernel void scalarScaledAdd(const dlong N,
                             const dfloat a,
                             const dfloat b,
                             @ restrict const dfloat *X,
                             @ restrict dfloat *Y)
{
  for (dlong n = 0; n < N; ++n; @tile(256, @outer, @inner)) {
    if (n < N) {
      Y[n] = a + b * X[n];
    }
  }
}

void udfDirichlet(bcData *bc)
{
  bc->sScalar = 0;
}

#endif

void extractLine(nrs_t *nrs, double time)
{
  const auto np = (platform->comm.mpiRank() == 0) ? 200 : 0;
  const auto offset = np;

  static pointInterpolation_t *interpolator = nullptr;
  static std::vector<dfloat> xp, yp, zp;
  static deviceMemory<dfloat> o_Up;

  if (!interpolator) {
    auto mesh = nrs->meshV;
    const auto yMin = platform->linAlg->min(mesh->Nlocal, mesh->o_y, platform->comm.mpiComm());
    const auto yMax = platform->linAlg->max(mesh->Nlocal, mesh->o_y, platform->comm.mpiComm());

    if (np) {
      const auto x0 = 7.0;
      const auto z0 = 0.5;

      xp.push_back(x0);
      yp.push_back(yMin);
      zp.push_back(z0);

      const auto betaY = 2.2;
      const auto dy = (yMax - yMin) / (np - 1);
      for (int i = 1; i < np - 1; i++) {
        xp.push_back(x0);
        yp.push_back(tanh(betaY * (i * dy - 1)) / tanh(betaY));
        zp.push_back(z0);
      }

      xp.push_back(x0);
      yp.push_back(yMax);
      zp.push_back(z0);
      o_Up.resize(mesh->dim * offset);
    }

    interpolator = new pointInterpolation_t(mesh, platform->comm.mpiComm());
    interpolator->setPoints(xp, yp, zp);
    interpolator->find();
  }

  interpolator->eval(nrs->meshV->dim, nrs->fluid->fieldOffset, nrs->fluid->o_U, offset, o_Up);

  if (platform->comm.mpiRank() == 0) {
    std::vector<dfloat> Up(nrs->meshV->dim * np);
    o_Up.copyTo(Up);

    std::ofstream f("profile.dat", std::ios::app);
    for (int i = 0; i < np; i++) {
      f << std::scientific << time << " " << xp[i] << " " << yp[i] << " " << zp[i] << " "
        << Up[i + 0 * offset] << " " << Up[i + 1 * offset] << " " << Up[i + 2 * offset] << std::endl;
    }
    f.close();
  }
}

void userq(double time)
{
  RANSktau::updateSourceTerms();
}

void uservp(double time)
{
  auto mesh = nrs->meshV;
  auto& scalar = nrs->scalar;

  RANSktau::updateProperties();

  dfloat conductivity;
  platform->options.getArgs("SCALAR00 DIFFUSIVITY", conductivity);
  const dfloat Pr_t = 0.85;
  scalarScaledAdd(mesh->Nlocal, conductivity, 1 / Pr_t, RANSktau::o_mue_t(), scalar->o_diffusionCoeff("temperature"));

#if 0
  if (platform->verbose()) {
    const dfloat debugNorm = platform->linAlg->weightedNorm2Many(mesh->Nlocal,
                                                                 1,
                                                                 nrs->fluid->fieldOffset,
                                                                 mesh->ogs->o_invDegree,
                                                                 o_mue_t,
                                                                 platform->comm.mpiComm());
    if (platform->comm.mpiRank() == 0) {
      printf("mue_t norm: %.15e\n", debugNorm);
    }                                   
  }
#endif
}

void UDF_LoadKernels(deviceKernelProperties& kernelInfo)
{
#if 0
  {
    auto props = kernelInfo;
    props.define("p_sigma_k") = 0.6;
    RANSktau::buildKernel(props);
  }
#endif
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  options.getArgs("CI-MODE", ciMode);
  if (ciMode) {
    ciSetup(comm, options);
  }
}

void UDF_Setup()
{
  nrs->userProperties = &uservp;
  nrs->userSource = &userq;

  auto mesh = nrs->meshV;

  std::vector<dfloat> U(mesh->dim * nrs->fluid->fieldOffset, 0.0);
  std::vector<dfloat> s0(mesh->Nlocal, 0.0);
  std::vector<dfloat> k(mesh->Nlocal, 0.0);
  std::vector<dfloat> tau(mesh->Nlocal, 0.0);

  if (platform->options.getArgs("RESTART FILE NAME").empty()) {
    auto& scalar = nrs->scalar;
    for(int n = 0; n < mesh->Nlocal; n++) {
      U[n + 0 * nrs->fluid->fieldOffset] = 1;
      U[n + 1 * nrs->fluid->fieldOffset] = 0;
      U[n + 2 * nrs->fluid->fieldOffset] = 0;
      s0[n] = 1.0;
      k[n] = 0.01; 
      tau[n] = 0.1;
    }
    nrs->fluid->o_U.copyFrom(U.data(), U.size());
    nrs->scalar->o_solution("temperature").copyFrom(s0.data(), s0.size()); 
    nrs->scalar->o_solution("k").copyFrom(k.data(), k.size()); 
    nrs->scalar->o_solution("tau").copyFrom(tau.data(), tau.size()); 
  }

  RANSktau::setup(nrs->scalar->nameToIndex.find("k")->second);
}

void UDF_ExecuteStep(double time, int tstep)
{
  if (ciMode) {
    ciTestErrors(nrs, time, tstep);
  }
  if (nrs->checkpointStep) {
    extractLine(nrs, time);
  }
}

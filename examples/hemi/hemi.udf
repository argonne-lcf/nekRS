#include "lpm.hpp"
#include "linspaceVector.hpp"

static dfloat Stk;
static dlong nParticlesInject;
static dlong injectionFrequency;
static deviceMemory<dfloat> o_yNewPart; // for adding new particles
static deviceMemory<dfloat> o_propNewPart;

static dfloat xMin;
static dfloat yMin;
static dfloat zMin;
static dfloat xMax;
static dfloat yMax;
static dfloat zMax;

static lpm_t *particles = nullptr;

#ifdef __okl__

void udfDirichlet(bcData *bc)
{
  if (isField("fluid velocity")) {
    const dfloat arg = bc->z * M_PI * 0.5 / 0.6;
    if (arg > 0.5 * M_PI) {
      bc->uxFluid = 1.0;
    } else {
      bc->uxFluid = sin(arg);
    }
 
    bc->uyFluid = 0.0;
    bc->uzFluid = 0.0;
  } if (isField("fluid pressure")) {
    const dfloat iU0delta = 10.0;
    const dfloat un = bc->uxFluid * bc->nx + bc->uyFluid * bc->ny + bc->uzFluid * bc->nz;
    const dfloat s0 = 0.5 * (1.0 - tanh(un * iU0delta));
    bc->pFluid = -0.5 * (bc->uxFluid * bc->uxFluid + bc->uyFluid * bc->uyFluid + bc->uzFluid * bc->uzFluid) * s0;
  }
}

@kernel void particleRHS(const dlong N,
                         const dlong offset,
                         @ restrict const dfloat *y,
                         @ restrict const dfloat *prop,
                         @ restrict const dfloat *U,
                         @ restrict dfloat *ydot)
{
  for (dlong n = 0; n < N; ++n; @tile(p_blockSize, @outer, @inner)) {
    const dfloat xx = y[n + 0 * offset];
    const dfloat yy = y[n + 1 * offset];
    const dfloat zz = y[n + 2 * offset];

    const dfloat vx = y[n + 3 * offset];
    const dfloat vy = y[n + 4 * offset];
    const dfloat vz = y[n + 5 * offset];

    const dfloat Ux = U[n + 0 * offset];
    const dfloat Uy = U[n + 1 * offset];
    const dfloat Uz = U[n + 2 * offset];

    const dfloat Stk = prop[n];
    const dfloat invStk = 1.0 / Stk;

    // dx_i/dt = v_i
    ydot[n + 0 * offset] = vx;
    ydot[n + 1 * offset] = vy;
    ydot[n + 2 * offset] = vz;

    // dv_i/dt = 1/Stk * (U_i - v_i)
    ydot[n + 3 * offset] = invStk * (Ux - vx);
    ydot[n + 4 * offset] = invStk * (Uy - vy);
    ydot[n + 5 * offset] = invStk * (Uz - vz);
  }
}

#endif

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  int commSize;
  MPI_Comm_size(comm, &commSize);

  int rank;
  MPI_Comm_rank(comm, &rank);

  platform->par->extract("casedata", "stk", Stk);
  platform->par->extract("casedata", "nparticlesinject", nParticlesInject);
  platform->par->extract("casedata", "injectionfrequency", injectionFrequency);
}

void userRHS(lpm_t *lpm, double time, const deviceMemory<dfloat>& o_y, void *userdata, deviceMemory<dfloat>& o_ydot)
{
  auto offset = lpm->fieldOffset();

  // evaluate fluid fields at particle positions
  lpm->interpolate();

  auto o_Uinterp = lpm->getInterpField("fluid_velocity");

  if (lpm->numParticles()) {
    auto o_prop = particles->getProp("stokes_number"); 
    particleRHS(lpm->numParticles(), offset, o_y, o_prop, o_Uinterp, o_ydot);
  }
}

// generate uniform points distributed at inflow
auto generateInflowPoints(nrs_t *nrs)
{
  auto numGlobalParticles = particles->numGlobalParticles();

  std::vector<dfloat> xPart, yPart, zPart;

  auto mesh = nrs->meshV;

  const auto py = static_cast<int>(std::round(std::sqrt(nParticlesInject)));
  const auto pz = py;

  const auto yPoint = linspace<dfloat>(yMin, yMax, py);
  const auto zPoint = linspace<dfloat>(zMin, zMax, pz);

  for (auto &&y : yPoint) {
    for (auto &&z : zPoint) {
      if (numGlobalParticles % platform->comm.mpiCommSize() == platform->comm.mpiRank()) {
        xPart.push_back(xMin);
        yPart.push_back(y);
        zPart.push_back(z);
      }
      numGlobalParticles++;
    }
  }

  return std::make_tuple(xPart, yPart, zPart);
}

void UDF_Setup()
{
  auto mesh = nrs->meshV;

  if (platform->options.getArgs("RESTART FILE NAME").empty()) {
    auto [x, y, z] = mesh->xyzHost();

    std::vector<dfloat> U(mesh->dim * nrs->fieldOffset, 0.0);
    const auto c1 = M_PI * 0.5/0.6;
    for(int n = 0; n < mesh->Nlocal; n++) {
      const auto arg = c1 * z[n];
      U[n + 0 * nrs->fieldOffset] = (arg > 0.5*M_PI) ? 1.0 : sin(arg);
      U[n + 1 * nrs->fieldOffset] = 0;
      U[n + 2 * nrs->fieldOffset] = 0;
    }
    nrs->fluid->o_U.copyFrom(U.data(), U.size());
  }

  xMin = platform->linAlg->min(mesh->Nlocal, mesh->o_x, platform->comm.mpiComm());
  yMin = platform->linAlg->min(mesh->Nlocal, mesh->o_y, platform->comm.mpiComm());
  zMin = platform->linAlg->min(mesh->Nlocal, mesh->o_z, platform->comm.mpiComm());

  xMax = platform->linAlg->max(mesh->Nlocal, mesh->o_x, platform->comm.mpiComm());
  yMax = platform->linAlg->max(mesh->Nlocal, mesh->o_y, platform->comm.mpiComm());
  zMax = platform->linAlg->max(mesh->Nlocal, mesh->o_z, platform->comm.mpiComm());

  const dfloat newton_tol = 5e-13;
  const dfloat bb_tol = 1e-4;

  particles = new lpm_t(mesh, nrs->dt, bb_tol, newton_tol);
  particles->setUserRHS(userRHS);

  particles->setSolver("AB");

  // register fluid velocity as an interpolated quantity
  particles->addInterpField("fluid_velocity", mesh->dim, nrs->fluid->fieldOffset, nrs->fluid->o_U);

  // register particle velocity as DOF
  particles->addVariable(mesh->dim, "velocity");

  // register Stokes number as a property
  particles->addProp("stokes_number");

  auto [xPart, yPart, zPart] = generateInflowPoints(nrs);
  const dlong nParticles = xPart.size();

  // interpolate initial fluid velocity onto particle positions
  auto interpolator = pointInterpolation_t(mesh, platform->comm.mpiComm());
  interpolator.setPoints(xPart, yPart, zPart);
  interpolator.find();

  poolDeviceMemory<dfloat> o_particleU0(mesh->dim * nParticles); 
  interpolator.eval(mesh->dim, nrs->fieldOffset, nrs->fluid->o_U, nParticles, o_particleU0);
  std::vector<dfloat> particleU0(o_particleU0.size());
  o_particleU0.copyTo(particleU0);

  // set particle initial positions and velocities
  std::vector<dfloat> y0(particles->nDOFs() * nParticles);

  for (int pid = 0; pid < nParticles; ++pid) {
    const auto x = xPart[pid];
    const auto y = yPart[pid];
    const auto z = zPart[pid];

    const auto u = particleU0[pid + 0 * nParticles];
    const auto v = particleU0[pid + 1 * nParticles];
    const auto w = particleU0[pid + 2 * nParticles];

    y0[pid + 0 * nParticles] = x;
    y0[pid + 1 * nParticles] = y;
    y0[pid + 2 * nParticles] = z;

    y0[pid + 3 * nParticles] = u;
    y0[pid + 4 * nParticles] = v;
    y0[pid + 5 * nParticles] = w;
  }

  dfloat t0;
  platform->options.getArgs("START TIME", t0);
  particles->initialize(nParticles, t0, y0);

  // set Stokes number
  deviceMemory<dfloat> o_tmp(nParticles);
  platform->linAlg->fill(nParticles, Stk, o_tmp);
  particles->setProp("stokes_number", o_tmp); 
}

void addNewParticles(nrs_t *nrs, double time, int tstep)
{
  auto mesh = nrs->meshV;
  auto numGlobalParticles = particles->numGlobalParticles();

  auto [xPart, yPart, zPart] = generateInflowPoints(nrs);
  const int nPartAdd = xPart.size();

  const auto NNewYPart = nPartAdd * particles->nDOFs();
  if (o_yNewPart.length() < NNewYPart) {
    if (o_yNewPart.byte_size()) {
      o_yNewPart.clear();
    }
    o_yNewPart.resize(NNewYPart);
  }

  const auto NNewPropPart = nPartAdd * particles->nProps();
  if (o_propNewPart.length() < NNewPropPart) {
    if (o_propNewPart.byte_size()) {
      o_propNewPart.clear();
    }
    o_propNewPart.resize(NNewPropPart);
  }

  auto o_xPart = o_yNewPart + 0 * nPartAdd;
  auto o_yPart = o_yNewPart + 1 * nPartAdd;
  auto o_zPart = o_yNewPart + 2 * nPartAdd;
  auto o_UPart = o_yNewPart + 3 * nPartAdd;

  o_xPart.copyFrom(xPart.data(), nPartAdd);
  o_yPart.copyFrom(yPart.data(), nPartAdd);
  o_zPart.copyFrom(zPart.data(), nPartAdd);

  // set property with Stokes number
  platform->linAlg->fill(nPartAdd, Stk, o_propNewPart);

  // interpolate fluid velocity onto new particle positions (set initial velocity as fluid velocity)
  auto interpolator = pointInterpolation_t(nrs->meshV, platform->comm.mpiComm());
  interpolator.setPoints(xPart, yPart, zPart);
  interpolator.find();

  interpolator.eval(mesh->dim, nrs->fluid->fieldOffset, nrs->fluid->o_U, nPartAdd, o_UPart);

  particles->addParticles(nPartAdd, o_yNewPart, o_propNewPart);
}

void UDF_ExecuteStep(double time, int tstep)
{
  particles->integrate(time);

  if (tstep % injectionFrequency == 0) {
    addNewParticles(nrs, time, tstep);
  }

  // Perform a particle migration if either condition is true:
  // If more than 10% of particles cannot be evaluated on the owning processor, migrate particles to the
  // correct position. If more than 10% of particles are unfound, migrate particles to the correct position.
  const auto migrationFraction = 0.1;
  const auto numNonLocalParticles = particles->numNonLocalParticles();
  const auto numUnfoundParticles = particles->numUnfoundParticles();

  double nonLocalParticleFraction = 0.0;
  double unfoundParticleFraction = 0.0;
  if (particles->numParticles()) {
    nonLocalParticleFraction = (double)numNonLocalParticles / (double)particles->numParticles();
    unfoundParticleFraction = (double)numUnfoundParticles / (double)particles->numParticles();
  }

  std::array<dfloat, 2> maxFractions = {nonLocalParticleFraction, unfoundParticleFraction};
  MPI_Allreduce(MPI_IN_PLACE,
                maxFractions.data(),
                maxFractions.size(),
                MPI_DFLOAT,
                MPI_MAX,
                platform->comm.mpiComm());
  if (platform->comm.mpiRank() == 0) {
    printf("nonLocalParticleFraction = %f, unfoundParticleFraction = %f\n", maxFractions[0], maxFractions[1]);
  }

  if ((maxFractions[0] > migrationFraction) || (maxFractions[1] > migrationFraction)) {
    particles->migrate();
  }

  if (nrs->checkpointStep) {
    nrs->copyToNek(time, tstep);
    nek::userchk(); // compute lambda2
    nrs->copyFromNek(time);

    particles->writeToFile();
  }
}

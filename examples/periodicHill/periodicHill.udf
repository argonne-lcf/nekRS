#include "RANSktau.hpp"
#include "tavg.hpp"

#include "ci.inc"

#ifdef __okl__

void udfDirichlet(bcData *bc)
{
  bc->sScalar = 0.0;
}

#endif

std::unique_ptr<tavg> avg;

dfloat hill_step(dfloat x, dfloat w, dfloat h)
{
  const dfloat xs = x / w;

  if (xs <= 0.0) {
    return h;
  } else if (xs > 0.0 && xs < 9. / 54.) {
    return h * std::min(1.0, 1. + 7.05575248e-1 * xs * xs - 1.1947737203e1 * xs * xs * xs);
  } else if (xs > 9. / 54. && xs < 14. / 54.) {
    return h * (0.895484248 + 1.881283544 * xs - 10.582126017 * xs * xs + 10.627665327 * xs * xs * xs);
  } else if (xs > 14. / 54. && xs < 20. / 54.) {
    return h * (0.92128609 + 1.582719366 * xs - 9.430521329 * xs * xs + 9.147030728 * xs * xs * xs);
  } else if (xs > 20. / 54. && xs < 30. / 54.) {
    return h * (1.445155365 - 2.660621763 * xs + 2.026499719 * xs * xs - 1.164288215 * xs * xs * xs);
  } else if (xs > 30. / 54. && xs < 40. / 54.) {
    return h * (0.640164762 + 1.6863274926 * xs - 5.798008941 * xs * xs + 3.530416981 * xs * xs * xs);
  } else if (xs > 40. / 54. && xs <= 1.0) {
    return h * (2.013932568 - 3.877432121 * xs + 1.713066537 * xs * xs + 0.150433015 * xs * xs * xs);
  } else {
    return 0.0;
  }
}

dfloat hill_height(dfloat x, dfloat Lx, dfloat w, dfloat h)
{
  dfloat xx = x;

  if (x < 0.0) {
    xx = Lx + std::fmod(x, Lx);
  } else if (x > Lx) {
    xx = std::fmod(x, Lx);
  }

  return hill_step(xx, w, h) + hill_step(Lx - xx, w, h);
}

dfloat shift(dfloat x, dfloat y, dfloat Lx, dfloat Ly, dfloat W)
{
  const dfloat yfac = std::pow(1. - y / Ly, 3);

  dfloat xfac = 0.0;
  if (x <= W / 2.0) {
    xfac = -2. / W * x;
  } else if (x > W / 2.0 && x <= Lx - W / 2.0) {
    xfac = 2. / (Lx - W) * x - 1 - W / (Lx - W);
  } else if (x > Lx - W / 2.0) {
    xfac = -2. / W * x + 2.0 * Lx / W;
  }

  return xfac * yfac;
}

void userq(double time)
{
  RANSktau::updateSourceTerms();
}

void uservp(double time)
{
  RANSktau::updateProperties();
}

void UDF_LoadKernels(deviceKernelProperties &kernelInfo)
{
#if 0
  {
    auto props = kernelInfo;
    props.define("p_edd_free") = 0.01; //for external flows
    props.define("p_ywlim") = 0.5;     //for external flows
    RANSktau::buildKernel(props);
  }
#endif
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  options.getArgs("CI-MODE", ciMode);
  if (ciMode) {
    ciSetup(comm, options);
  }
}

void UDF_Setup()
{
  nrs->userProperties = &uservp;
  nrs->userSource = &userq;

  auto mesh = nrs->meshV;

  if (platform->options.getArgs("RESTART FILE NAME").empty()) {
    std::vector<dfloat> U(nrs->fluid->fieldOffsetSum, 0.0);
    std::vector<dfloat> k(mesh->Nlocal, 0.0);
    std::vector<dfloat> tau(mesh->Nlocal, 0.0);
    for (int n = 0; n < mesh->Nlocal; n++) {
      U[n + 0 * nrs->fieldOffset] = 1;
      k[n] = 0.01;
      tau[n] = 0.1;
    }
    nrs->fluid->o_U.copyFrom(U.data(), U.size());
    nrs->scalar->o_solution("k").copyFrom(k.data(), k.size());
    nrs->scalar->o_solution("tau").copyFrom(tau.data(), tau.size());
  }

  // Box mesh manipulation
  const auto betax = 2.0;
  const auto betay = 2.4;
  const auto Lx = 9.0;
  const auto Ly = 3.035;
  const auto Lz = 4.5;
  const auto W = 1.929;
  const auto H = 1.0;
  const auto amp = 0.25;

  const auto xmin = platform->linAlg->min(mesh->Nlocal, mesh->o_x, platform->comm.mpiComm());
  const auto xmax = platform->linAlg->max(mesh->Nlocal, mesh->o_x, platform->comm.mpiComm());
  const auto ymin = platform->linAlg->min(mesh->Nlocal, mesh->o_y, platform->comm.mpiComm());
  const auto ymax = platform->linAlg->max(mesh->Nlocal, mesh->o_y, platform->comm.mpiComm());
  const auto zmin = platform->linAlg->min(mesh->Nlocal, mesh->o_z, platform->comm.mpiComm());
  const auto zmax = platform->linAlg->max(mesh->Nlocal, mesh->o_z, platform->comm.mpiComm());

  const auto xscale = Lx / (xmax - xmin);
  const auto yscale = Ly / (ymax - ymin);
  const auto zscale = Lz / (zmax - zmin);

  auto [x, y, z] = mesh->xyzHost();

  for (int n = 0; n < mesh->Nlocal; n++) {
    x[n] = 0.5 * (sinh(betax * (x[n] - 0.5)) / sinh(betax * 0.5) + 1.0);
    y[n] = 0.5 * (tanh(betay * (2.0 * y[n] - 1.0)) / tanh(betay) + 1.0);

    x[n] = (x[n] - xmin) * xscale;
    y[n] = (y[n] - ymin) * yscale;
    z[n] = (z[n] - zmin) * zscale;

    x[n] = x[n] + amp * shift(x[n], y[n], Lx, Ly, W);

    auto yh = hill_height(x[n], Lx, W, H);
    y[n] = yh + y[n] * (1.0 - yh / Ly);
  }
  mesh->o_x.copyFrom(x.data());
  mesh->o_y.copyFrom(y.data());
  mesh->o_z.copyFrom(z.data());

  std::string model = "ktausst";
  if (ciMode == 2) {
    model = "ktausst+ddes";
  }
  if (ciMode == 3) {
    model = "ktausst+iddes";
  }
  RANSktau::setup(nrs->scalar->nameToIndex.find("k")->second, model);

  if (ciMode) {
    std::vector<tavg::field> tavgFields;

    deviceMemory<dfloat> o_u(nrs->fluid->o_solution("x"));
    deviceMemory<dfloat> o_v(nrs->fluid->o_solution("y"));
    deviceMemory<dfloat> o_w(nrs->fluid->o_solution("z"));

    tavgFields.push_back({"ux", std::vector{o_u}});
    tavgFields.push_back({"uy", std::vector{o_v}});
    tavgFields.push_back({"uz", std::vector{o_w}});

    avg = std::make_unique<tavg>(nrs->fluid->fieldOffset, tavgFields);
  }
}

void UDF_ExecuteStep(double time, int tstep)
{
  if (ciMode) {
    if (nrs->timeStepConverged) {
      avg->run(time);
    }

    ciTestErrors(nrs, time, tstep, avg->o_data());
  }
}

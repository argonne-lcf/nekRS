#include "ci.inc"

/* User Functions */

static dfloat P_ROT;
static dfloat visc;

#ifdef __okl__

@kernel void cfill(const dlong N, const dlong offset, const dfloat angle, const dfloat dp, @ restrict dfloat *NU)
{
  for (dlong n = 0; n < N; ++n; @tile(p_blockSize, @outer, @inner)) {
    if (n < N) {

      const dfloat dpdx = dp * cos(angle);
      const dfloat dpdy = dp * sin(angle);
      const dfloat dpdz = 0.0;

      NU[n + 0 * offset] = dpdx;
      NU[n + 1 * offset] = dpdy;
      NU[n + 2 * offset] = dpdz;
    }
  }
}

// Boundary conditions
void udfNeumann(bcData *bc)
{
  bc->tr1 = -3.0 * p_visc;
  bc->tr2 = 0.0;
}

#endif

void userf(double time)
{
  auto mesh = nrs->meshV;
  const dfloat DP = 3.0 * visc;
  cfill(mesh->Nlocal, nrs->fieldOffset, P_ROT, DP, nrs->fluid->o_EXT);
}

void UDF_LoadKernels(deviceKernelProperties &kernelInfo)
{
  platform->options.getArgs("FLUID VISCOSITY", visc);
  kernelInfo.define("p_visc") = visc;
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  options.getArgs("CI-MODE", ciMode);
  if (ciMode) {
    ciSetup(comm, options);
  }
  platform->par->extract("casedata", "p_rot", P_ROT);
  if (platform->options.compareArgs("BUILD ONLY", "FALSE")) {
    *nek::ptr<double>("p_rot") = P_ROT;
  }
}

void UDF_Setup()
{
  nrs->userSource = &userf;
}

void UDF_ExecuteStep(double time, int tstep)
{
  if (nrs->checkpointStep) {
    nrs->copyToNek(time, tstep);
    nek::userchk();
  }
  if (ciMode) {
    ciTestErrors(nrs, time, tstep);
  }
}
